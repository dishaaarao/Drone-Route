<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drone Delivery Route Planner</title>
    <!-- Firebase SDK -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js";
        import { 
            getAuth, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword,
            signOut,
            onAuthStateChanged
        } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { 
            getFirestore, 
            collection, 
            addDoc, 
            getDocs, 
            query, 
            where,
            orderBy,
            serverTimestamp,
            updateDoc,
            doc
        } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCPvVwJ3Z2lVH18iXKLMxOsoG8BsmGANwA",
            authDomain: "drone-route-planner-7c5b8.firebaseapp.com",
            projectId: "drone-route-planner-7c5b8",
            storageBucket: "drone-route-planner-7c5b8.firebasestorage.app",
            messagingSenderId: "771436681045",
            appId: "1:771436681045:web:cd36faa3ba41d0638ec1dc",
            measurementId: "G-Z3E6ZMBT3T"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        // Make Firebase available globally
        window.firebaseApp = app;
        window.firebaseAuth = auth;
        window.firebaseDB = db;
        window.firebaseAnalytics = analytics;
        
        console.log("Firebase initialized successfully!");

        // Auth state observer
        onAuthStateChanged(auth, (user) => {
            const authSection = document.getElementById('auth-section');
            const userInfo = document.getElementById('user-info');
            
            if (user) {
                // User is signed in
                authSection.style.display = 'none';
                userInfo.style.display = 'block';
                document.getElementById('user-email').textContent = user.email;
                console.log('User is signed in:', user.email);
            } else {
                // User is signed out
                authSection.style.display = 'block';
                userInfo.style.display = 'none';
                console.log('User is signed out');
            }
        });

        // Auth functions
        window.signUp = async (email, password) => {
            try {
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                console.log('User created:', userCredential.user);
                alert('Account created successfully!');
            } catch (error) {
                console.error('Error signing up:', error);
                alert('Error: ' + error.message);
            }
        };

        window.signIn = async (email, password) => {
            try {
                const userCredential = await signInWithEmailAndPassword(auth, email, password);
                console.log('User signed in:', userCredential.user);
            } catch (error) {
                console.error('Error signing in:', error);
                alert('Error: ' + error.message);
            }
        };

        window.signOutUser = async () => {
            try {
                await signOut(auth);
                console.log('User signed out');
            } catch (error) {
                console.error('Error signing out:', error);
            }
        };

        // Firestore functions
        window.saveDelivery = async (deliveryData) => {
            try {
                const user = auth.currentUser;
                if (!user) throw new Error('User not authenticated');
                
                const docRef = await addDoc(collection(db, 'deliveries'), {
                    ...deliveryData,
                    userId: user.uid,
                    status: 'pending',
                    createdAt: serverTimestamp(),
                    updatedAt: serverTimestamp()
                });
                console.log('Delivery saved with ID: ', docRef.id);
                return docRef.id;
            } catch (error) {
                console.error('Error saving delivery: ', error);
                throw error;
            }
        };

        window.getUserDeliveries = async () => {
            try {
                const user = auth.currentUser;
                if (!user) throw new Error('User not authenticated');
                
                const q = query(
                    collection(db, 'deliveries'),
                    where('userId', '==', user.uid),
                    orderBy('createdAt', 'desc')
                );
                
                const querySnapshot = await getDocs(q);
                const deliveries = [];
                querySnapshot.forEach((doc) => {
                    deliveries.push({ id: doc.id, ...doc.data() });
                });
                return deliveries;
            } catch (error) {
                console.error('Error getting deliveries: ', error);
                throw error;
            }
        };

        // Image handling functions
        window.uploadDeliveryImage = async (file, deliveryId) => {
            try {
                const user = auth.currentUser;
                if (!user) throw new Error('User not authenticated');
                
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        const base64String = e.target.result;
                        // Store in Firestore
                        const deliveryRef = doc(db, 'deliveries', deliveryId);
                        await updateDoc(deliveryRef, {
                            imageBase64: base64String,
                            imageName: file.name,
                            imageType: file.type,
                            updatedAt: serverTimestamp()
                        });
                        resolve({ url: base64String, name: file.name });
                    };
                    reader.onerror = error => reject(error);
                    reader.readAsDataURL(file);
                });
            } catch (error) {
                console.error('Error uploading image:', error);
                throw error;
            }
        };

        window.deleteDeliveryImage = async (deliveryId) => {
            try {
                const deliveryRef = doc(db, 'deliveries', deliveryId);
                await updateDoc(deliveryRef, {
                    imageBase64: null,
                    imageName: null,
                    imageType: null,
                    updatedAt: serverTimestamp()
                });
                console.log('Image reference removed from delivery');
                return true;
            } catch (error) {
                console.error('Error removing image:', error);
                throw error;
            }
        };
    </script>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>
    <!-- Update the style section in the head -->
<style>
    /* Base Styles and Variables */
    :root {
        --primary: #4e73df;
        --primary-dark: #2e59d9;
        --primary-light: #e8f0fe;
        --secondary: #6c757d;
        --success: #1cc88a;
        --info: #36b9cc;
        --warning: #f6c23e;
        --danger: #e74a3b;
        --light: #f8f9fc;
        --dark: #5a5c69;
        --gray-100: #f8f9fc;
        --gray-200: #e3e6f0;
        --gray-300: #d1d3e2;
        --gray-600: #858796;
        --border-radius: 0.5rem;
        --box-shadow: 0 0.15rem 1.75rem 0 rgba(58, 59, 69, 0.15);
        --transition: all 0.2s ease-in-out;
    }

    /* Base Typography */
    body {
        font-family: 'Nunito', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        color: var(--dark);
        background-color: var(--gray-100);
        display: flex;
        flex-direction: column;
        height: 100vh;
        overflow: hidden;
        margin: 0;
        padding: 0;
    }

    /* Header Styles */
    header {
        background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
        color: white;
        padding: 1rem 2rem;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        z-index: 1000;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .header-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        max-width: 1400px;
        margin: 0 auto;
    }

    .logo {
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }

    .logo h1 {
        font-size: 1.5rem;
        font-weight: 700;
        margin: 0;
        color: white;
    }

    .user-menu {
        display: flex;
        align-items: center;
        gap: 1rem;
    }

    .user-avatar {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background-color: rgba(255, 255, 255, 0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: var(--transition);
    }

    .user-avatar:hover {
        background-color: rgba(255, 255, 255, 0.3);
    }

    .dropdown-menu {
        position: absolute;
        top: 100%;
        right: 1rem;
        background: white;
        border-radius: var(--border-radius);
        box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.1);
        min-width: 200px;
        opacity: 0;
        visibility: hidden;
        transform: translateY(10px);
        transition: var(--transition);
        z-index: 1001;
    }

    .dropdown-menu.show {
        opacity: 1;
        visibility: visible;
        transform: translateY(0);
    }

    .dropdown-item {
        padding: 0.75rem 1.25rem;
        color: var(--dark);
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        transition: var(--transition);
    }

    .dropdown-item:hover {
        background-color: var(--gray-100);
        color: var(--primary);
    }

    .dropdown-divider {
        height: 1px;
        background-color: var(--gray-200);
        margin: 0.25rem 0;
    }

    /* Main Container */
    .container {
        display: flex;
        flex: 1;
        overflow: hidden;
        position: relative;
    }

    /* Map Container */
    #map {
        flex: 2;
        height: 100%;
        z-index: 1;
        transition: var(--transition);
    }

    /* Dashboard Styles */
    .dashboard {
        flex: 0 0 400px;
        background: white;
        overflow-y: auto;
        box-shadow: -2px 0 10px rgba(0, 0, 0, 0.05);
        border-left: 1px solid var(--gray-200);
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
    }

    .dashboard-header {
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid var(--gray-200);
    }

    .dashboard-title {
        font-size: 1.25rem;
        font-weight: 700;
        color: var(--dark);
        margin: 0;
    }

    .dashboard-content {
        flex: 1;
        overflow-y: auto;
    }

    /* Form Elements */
    .form-group {
        margin-bottom: 1.25rem;
    }

    .form-label {
        display: block;
        margin-bottom: 0.5rem;
        font-size: 0.875rem;
        font-weight: 600;
        color: var(--dark);
    }

    .form-control {
        width: 100%;
        padding: 0.75rem 1rem;
        font-size: 0.9rem;
        line-height: 1.5;
        color: var(--dark);
        background-color: #fff;
        border: 1px solid var(--gray-300);
        border-radius: var(--border-radius);
        transition: var(--transition);
    }

    .form-control:focus {
        border-color: var(--primary);
        box-shadow: 0 0 0 0.2rem rgba(78, 115, 223, 0.25);
        outline: 0;
    }

    /* Buttons */
    .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.75rem 1.5rem;
        font-size: 0.9rem;
        font-weight: 600;
        line-height: 1.5;
        text-align: center;
        white-space: nowrap;
        vertical-align: middle;
        cursor: pointer;
        user-select: none;
        border: 1px solid transparent;
        border-radius: var(--border-radius);
        transition: var(--transition);
    }

    .btn-primary {
        color: #fff;
        background-color: var(--primary);
        border-color: var(--primary);
    }

    .btn-primary:hover {
        background-color: var(--primary-dark);
        border-color: var(--primary-dark);
        transform: translateY(-1px);
    }

    .btn-secondary {
        color: #fff;
        background-color: var(--secondary);
        border-color: var(--secondary);
    }

    .btn-secondary:hover {
        background-color: #5a6268;
        border-color: #545b62;
        transform: translateY(-1px);
    }

    .btn-outline-primary {
        color: var(--primary);
        background-color: transparent;
        border: 1px solid var(--primary);
    }

    .btn-outline-primary:hover {
        color: #fff;
        background-color: var(--primary);
    }

    .btn-group {
        display: flex;
        gap: 0.75rem;
        margin: 1.5rem 0;
    }

    .btn-group .btn {
        flex: 1;
    }

    /* Delivery Info Card */
    .card {
        background: white;
        border-radius: var(--border-radius);
        box-shadow: 0 0.15rem 0.5rem rgba(0, 0, 0, 0.03);
        border: 1px solid var(--gray-200);
        margin-bottom: 1.5rem;
        overflow: hidden;
    }

    .card-header {
        padding: 1rem 1.25rem;
        background-color: var(--light);
        border-bottom: 1px solid var(--gray-200);
        font-weight: 600;
        color: var(--dark);
    }

    .card-body {
        padding: 1.25rem;
    }

    .info-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
    }

    .info-item {
        margin-bottom: 0.75rem;
    }

    .info-label {
        font-size: 0.75rem;
        color: var(--gray-600);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 0.25rem;
    }

    .info-value {
        font-weight: 600;
        color: var(--dark);
    }

    /* Status Badge */
    .status-badge {
        display: inline-flex;
        align-items: center;
        padding: 0.35rem 0.75rem;
        font-size: 0.75rem;
        font-weight: 600;
        border-radius: 10rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .status-pending {
        background-color: #fff3cd;
        color: #856404;
    }

    .status-in-progress {
        background-color: #cce5ff;
        color: #004085;
    }

    .status-delivered {
        background-color: #d4edda;
        color: #155724;
    }

    /* Responsive Design */
    @media (max-width: 992px) {
        .container {
            flex-direction: column;
        }

        #map {
            height: 60vh;
        }

        .dashboard {
            flex: 1;
            max-width: 100%;
            border-left: none;
            border-top: 1px solid var(--gray-200);
        }
    }

    @media (max-width: 576px) {
        .header-content {
            flex-direction: column;
            gap: 1rem;
            padding: 0.75rem;
        }

        .logo h1 {
            font-size: 1.25rem;
        }

        .dashboard {
            padding: 1rem;
        }

        .btn-group {
            flex-direction: column;
        }
    }

    /* Animations */
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }

    .fade-in {
        animation: fadeIn 0.3s ease-out forwards;
    }

    /* Utility Classes */
    .mt-3 { margin-top: 1rem !important; }
    .mt-4 { margin-top: 1.5rem !important; }
    .mb-3 { margin-bottom: 1rem !important; }
    .mb-4 { margin-bottom: 1.5rem !important; }
    .text-center { text-align: center !important; }
    .d-flex { display: flex !important; }
    .flex-column { flex-direction: column !important; }
    .justify-content-between { justify-content: space-between !important; }
    .align-items-center { align-items: center !important; }
    .w-100 { width: 100% !important; }
</style>
</head>
<body>
    <header>
        <h1>Drone Delivery Route Planner</h1>
        <div id="auth-section" style="display: block; margin-top: 10px;">
            <input type="email" id="email" placeholder="Email" style="padding: 5px; margin: 0 5px;">
            <input type="password" id="password" placeholder="Password" style="padding: 5px; margin: 0 5px;">
            <button onclick="signIn(email.value, password.value)" style="padding: 5px 10px; margin: 0 5px;">Sign In</button>
            <button onclick="signUp(email.value, password.value)" style="padding: 5px 10px; margin: 0 5px;">Sign Up</button>
        </div>
        <div id="user-info" style="display: none; margin-top: 10px;">
            <span id="user-email" style="margin-right: 15px;"></span>
            <button onclick="signOutUser()" style="padding: 5px 10px; margin-right: 10px;">Sign Out</button>
            <button onclick="showDeliveryHistory()" style="padding: 5px 10px;">View My Deliveries</button>
        </div>
    </header>
    
    <div class="container">
        <!-- Map Container -->
        <div id="map"></div>
        
        <!-- Dashboard -->
        <div class="dashboard">
            <h2>Delivery Control Panel</h2>
            
            <!-- Delivery Form -->
            <div class="form-group">
                <label for="delivery-id">Delivery ID</label>
                <input type="text" id="delivery-id" readonly>
            </div>
            
            <div class="form-group">
                <label>Pickup Point</label>
                <div id="pickup-coords">Click on the map to set pickup point</div>
            </div>
            
            <div class="form-group">
                <label>Dropoff Point</label>
                <div id="dropoff-coords">Click on the map to set dropoff point</div>
            </div>
            
            <div class="form-group">
                <button id="find-route">Find Route</button>
                <button id="reset" class="secondary">Reset</button>
                <button id="save-delivery" onclick="saveCurrentDelivery()">Save Delivery</button>
            </div>
            
            <!-- Delivery Information Panel -->
            <div class="panel">
                <h2>Delivery Information</h2>
                <div class="form-group">
                    <label for="delivery-notes">Delivery Notes:</label>
                    <textarea id="delivery-notes" rows="3"></textarea>
                </div>
                <div class="form-group">
                    <label for="delivery-image">Attach Image (Optional):</label>
                    <input type="file" id="delivery-image" accept="image/*" style="display: none;">
                    <div style="display: flex; align-items: center; margin-top: 5px;">
                        <button onclick="document.getElementById('delivery-image').click()" style="padding: 5px 10px; margin-right: 10px;">
                            Choose Image
                        </button>
                        <span id="image-name" style="font-size: 0.9em; color: #666;">No image selected</span>
                    </div>
                    <div id="image-preview" style="margin-top: 10px; max-width: 100%; display: none;">
                        <img id="preview" src="#" alt="Preview" style="max-width: 200px; max-height: 150px; border: 1px solid #ddd; border-radius: 4px;">
                        <button onclick="removeImage()" style="margin-left: 10px; padding: 2px 5px; font-size: 0.8em;">Remove</button>
                    </div>
                </div>
                <div class="form-group">
                    <button id="save-delivery" onclick="saveCurrentDelivery()" style="margin-top: 10px;">Save Delivery</button>
                </div>
            </div>
            
            <!-- Delivery Information -->
            <div class="delivery-info">
                <h3>Delivery Information</h3>
                <div class="info-item">
                    <span class="info-label">Status:</span>
                    <span id="status"><span class="status-indicator status-idle"></span>Idle</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Route Distance:</span>
                    <span id="distance">-</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Estimated Time:</span>
                    <span id="time">-</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Nodes in Path:</span>
                    <span id="node-count">-</span>
                </div>
            </div>
            
            <!-- Instructions -->
            <div class="instructions" style="margin-top: 1.5rem; font-size: 0.9em; color: #7f8c8d;">
                <h4>Instructions:</h4>
                <ol style="padding-left: 1.2rem; margin-top: 0.5rem;">
                    <li>Click on the map to set pickup point (green)</li>
                    <li>Click again to set dropoff point (red)</li>
                    <li>Click "Find Route" to calculate the optimal path</li>
                    <li>Watch the drone deliver your package!</li>
                </ol>
            </div>
        </div>
    </div>

    <div id="delivery-history-modal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.3); z-index: 1000; max-height: 80vh; overflow-y: auto;">
        <h2>My Delivery History</h2>
        <div id="delivery-list" style="margin: 15px 0;">
            <!-- Delivery items will be added here -->
        </div>
        <button onclick="document.getElementById('delivery-history-modal').style.display = 'none'" style="padding: 5px 10px;">Close</button>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""></script>
    
    <script>
        // Wait for the DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize the map centered on Mumbai
            const map = L.map('map').setView([19.0760, 72.8777], 13);
            
            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
            
            // Initialize variables
            let pickupMarker = null;
            let dropoffMarker = null;
            let graph = null;
            let nodes = [];
            let edges = [];
            let path = [];
            let nodeMarkers = [];
            let edgeLines = [];
            let routeLine = null;
            let droneMarker = null;
            let droneAnimation = null;
            let deliveryId = null;
            
            // Generate a random delivery ID
            function generateDeliveryId() {
                return 'D' + Math.floor(1000 + Math.random() * 9000);
            }
            
            // Initialize the graph with sample data (nodes and edges)
            function initializeGraph() {
                // Clear existing nodes and edges
                nodes = [];
                edges = [];
                
                // Add some nodes around Mumbai
                // Format: { id, lat, lng, name }
                nodes = [
                    { id: 1, lat: 19.0760, lng: 72.8777, name: 'Mumbai Central' },
                    { id: 2, lat: 19.0765, lng: 72.8770, name: 'Node 2' },
                    { id: 3, lat: 19.0750, lng: 72.8780, name: 'Node 3' },
                    { id: 4, lat: 19.0770, lng: 72.8790, name: 'Node 4' },
                    { id: 5, lat: 19.0745, lng: 72.8760, name: 'Node 5' },
                    { id: 6, lat: 19.0780, lng: 72.8750, name: 'Node 6' },
                    { id: 7, lat: 19.0730, lng: 72.8785, name: 'Node 7' },
                    { id: 8, lat: 19.0790, lng: 72.8765, name: 'Node 8' }
                ];
                
                // Add edges between nodes with weights (distances)
                // Format: { from: nodeId, to: nodeId, weight: distance }
                edges = [
                    { from: 1, to: 2, weight: 0.1 },
                    { from: 1, to: 3, weight: 0.15 },
                    { from: 2, to: 4, weight: 0.2 },
                    { from: 2, to: 5, weight: 0.12 },
                    { from: 3, to: 6, weight: 0.25 },
                    { from: 4, to: 7, weight: 0.18 },
                    { from: 5, to: 8, weight: 0.22 },
                    { from: 6, to: 7, weight: 0.15 },
                    { from: 7, to: 8, weight: 0.3 },
                    { from: 4, to: 1, weight: 0.1 },
                    { from: 5, to: 2, weight: 0.12 },
                    { from: 6, to: 3, weight: 0.25 },
                    { from: 7, to: 4, weight: 0.18 },
                    { from: 8, to: 5, weight: 0.22 }
                ];
                
                // Create a graph representation (adjacency list)
                graph = {};
                nodes.forEach(node => {
                    graph[node.id] = [];
                });
                
                edges.forEach(edge => {
                    // Add edge in both directions for undirected graph
                    graph[edge.from].push({ to: edge.to, weight: edge.weight });
                    graph[edge.to].push({ to: edge.from, weight: edge.weight });
                });
            }
            
            // Calculate distance between two coordinates using Haversine formula
            function calculateDistance(lat1, lon1, lat2, lon2) {
                const R = 6371; // Earth's radius in km
                const dLat = toRad(lat2 - lat1);
                const dLon = toRad(lon2 - lon1);
                const a = 
                    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * 
                    Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c; // Distance in km
            }
            
            // Convert degrees to radians
            function toRad(degrees) {
                return degrees * (Math.PI / 180);
            }
            
            // Find the nearest node to a given lat/lng
            function findNearestNode(lat, lng) {
                let minDistance = Infinity;
                let nearestNode = null;
                
                nodes.forEach(node => {
                    const distance = calculateDistance(lat, lng, node.lat, node.lng);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestNode = node;
                    }
                });
                
                return nearestNode;
            }
            
            // A* pathfinding algorithm
            function aStar(graph, startId, endId) {
                // Heuristic function (Haversine distance to end node)
                const heuristic = (nodeId) => {
                    const node = nodes.find(n => n.id === nodeId);
                    const endNode = nodes.find(n => n.id === endId);
                    return calculateDistance(node.lat, node.lng, endNode.lat, endNode.lng);
                };
                
                // Initialize data structures
                const openSet = new Set([startId]);
                const cameFrom = {};
                
                // gScore[node] = cost of the cheapest path from start to node
                const gScore = {};
                nodes.forEach(node => {
                    gScore[node.id] = Infinity;
                });
                gScore[startId] = 0;
                
                // fScore[node] = gScore[node] + heuristic(node)
                const fScore = {};
                nodes.forEach(node => {
                    fScore[node.id] = Infinity;
                });
                fScore[startId] = heuristic(startId);
                
                // Main A* loop
                while (openSet.size > 0) {
                    // Find node in openSet with lowest fScore
                    let current = null;
                    let lowestFScore = Infinity;
                    
                    openSet.forEach(id => {
                        if (fScore[id] < lowestFScore) {
                            lowestFScore = fScore[id];
                            current = id;
                        }
                    });
                    
                    // If we've reached the end, reconstruct and return the path
                    if (current === endId) {
                        return reconstructPath(cameFrom, current);
                    }
                    
                    // Move current from openSet to closed set
                    openSet.delete(current);
                    
                    // Check all neighbors of current
                    graph[current].forEach(neighbor => {
                        const neighborId = neighbor.to;
                        // d(current,neighbor) is the weight of the edge from current to neighbor
                        // tentative_gScore is the distance from start to the neighbor through current
                        const tentativeGScore = gScore[current] + neighbor.weight;
                        
                        if (tentativeGScore < gScore[neighborId]) {
                            // This path to neighbor is better than any previous one
                            cameFrom[neighborId] = current;
                            gScore[neighborId] = tentativeGScore;
                            fScore[neighborId] = gScore[neighborId] + heuristic(neighborId);
                            
                            if (!openSet.has(neighborId)) {
                                openSet.add(neighborId);
                            }
                        }
                    });
                }
                
                // If we get here, there's no path
                return null;
            }
            
            // Reconstruct the path from cameFrom dictionary
            function reconstructPath(cameFrom, current) {
                const path = [current];
                while (cameFrom[current] !== undefined) {
                    current = cameFrom[current];
                    path.unshift(current);
                }
                return path;
            }
            
            // Draw the graph on the map
            function drawGraph() {
                // Clear existing markers and lines
                clearGraph();
                
                // Draw edges
                edges.forEach(edge => {
                    const fromNode = nodes.find(n => n.id === edge.from);
                    const toNode = nodes.find(n => n.id === edge.to);
                    
                    if (fromNode && toNode) {
                        const line = L.polyline(
                            [[fromNode.lat, fromNode.lng], [toNode.lat, toNode.lng]],
                            { color: '#9b59b6', weight: 2, opacity: 0.7 }
                        ).addTo(map);
                        
                        // Add weight label in the middle of the edge
                        const midLat = (fromNode.lat + toNode.lat) / 2;
                        const midLng = (fromNode.lng + toNode.lng) / 2;
                        
                        L.marker([midLat, midLng], {
                            icon: L.divIcon({
                                html: edge.weight.toFixed(2) + ' km',
                                className: 'edge-label',
                                iconSize: [40, 20]
                            }),
                            zIndexOffset: 1000
                        }).addTo(map);
                        
                        edgeLines.push(line);
                    }
                });
                
                // Draw nodes
                nodes.forEach(node => {
                    const marker = L.circleMarker([node.lat, node.lng], {
                        radius: 6,
                        fillColor: '#9b59b6',
                        color: '#fff',
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.8
                    }).addTo(map);
                    
                    // Add tooltip with node name
                    marker.bindTooltip(`Node ${node.id} (${node.name})`, { permanent: false, direction: 'top' });
                    
                    nodeMarkers.push(marker);
                });
            }
            
            // Clear graph visualization
            function clearGraph() {
                nodeMarkers.forEach(marker => map.removeLayer(marker));
                edgeLines.forEach(line => map.removeLayer(line));
                nodeMarkers = [];
                edgeLines = [];
            }
            
            // Draw the calculated path
            function drawPath(nodeIds) {
                // Clear existing path
                if (routeLine) {
                    map.removeLayer(routeLine);
                }
                
                const pathCoords = nodeIds.map(id => {
                    const node = nodes.find(n => n.id === id);
                    return [node.lat, node.lng];
                });
                
                routeLine = L.polyline(pathCoords, {
                    color: '#3498db',
                    weight: 5,
                    opacity: 0.7,
                    lineJoin: 'round'
                }).addTo(map);
                
                // Fit map to show the entire path
                map.fitBounds(routeLine.getBounds(), { padding: [50, 50] });
                
                return pathCoords;
            }
            
            // Animate drone along the path
            function animateDrone(pathCoords) {
                // Clear any existing animation
                if (droneMarker) {
                    map.removeLayer(droneMarker);
                }
                
                if (droneAnimation) {
                    clearInterval(droneAnimation);
                }
                
                // Create drone marker
                droneMarker = L.marker([pathCoords[0][0], pathCoords[0][1]], {
                    icon: L.divIcon({
                        className: 'drone-marker',
                        iconSize: [30, 30]
                    }),
                    zIndexOffset: 1000
                }).addTo(map);
                
                // Update status
                updateStatus('In Transit');
                
                // Calculate total distance for ETA
                let totalDistance = 0;
                for (let i = 0; i < pathCoords.length - 1; i++) {
                    totalDistance += calculateDistance(
                        pathCoords[i][0], pathCoords[i][1],
                        pathCoords[i+1][0], pathCoords[i+1][1]
                    );
                }
                
                // Update distance and time
                document.getElementById('distance').textContent = totalDistance.toFixed(2) + ' km';
                
                // Assume drone speed of 50 km/h
                const droneSpeed = 50; // km/h
                const estimatedHours = totalDistance / droneSpeed;
                const estimatedMinutes = Math.round(estimatedHours * 60);
                document.getElementById('time').textContent = `${estimatedMinutes} min (${droneSpeed} km/h)`;
                
                // Update node count
                document.getElementById('node-count').textContent = pathCoords.length;
                
                // Animate drone along the path
                let currentIndex = 0;
                droneAnimation = setInterval(() => {
                    if (currentIndex < pathCoords.length - 1) {
                        const start = pathCoords[currentIndex];
                        const end = pathCoords[currentIndex + 1];
                        const steps = 10;
                        let step = 0;
                        
                        const moveDrone = () => {
                            if (step <= steps) {
                                const ratio = step / steps;
                                const lat = start[0] + (end[0] - start[0]) * ratio;
                                const lng = start[1] + (end[1] - start[1]) * ratio;
                                
                                droneMarker.setLatLng([lat, lng]);
                                
                                // Rotate drone to face direction of travel
                                if (currentIndex < pathCoords.length - 1) {
                                    const nextPoint = pathCoords[currentIndex + 1];
                                    const angle = Math.atan2(nextPoint[1] - lng, nextPoint[0] - lat) * 180 / Math.PI + 90;
                                    droneMarker.setRotationAngle(angle);
                                }
                                
                                step++;
                                setTimeout(moveDrone, 100);
                            } else {
                                currentIndex++;
                                
                                // If we've reached the end of the path
                                if (currentIndex >= pathCoords.length - 1) {
                                    clearInterval(droneAnimation);
                                    updateStatus('Delivered');
                                    document.getElementById('find-route').disabled = false;
                                }
                            }
                        };
                        
                        moveDrone();
                    }
                }, 1000);
            }
            
            // Update status in the dashboard
            function updateStatus(status) {
                const statusElement = document.getElementById('status');
                const statusIndicator = statusElement.querySelector('.status-indicator');
                
                // Remove all status classes
                statusIndicator.className = 'status-indicator';
                
                // Add appropriate class based on status
                if (status === 'Idle') {
                    statusIndicator.classList.add('status-idle');
                } else if (status === 'In Transit') {
                    statusIndicator.classList.add('status-transit');
                } else if (status === 'Delivered') {
                    statusIndicator.classList.add('status-delivered');
                }
                
                // Update status text
                statusElement.innerHTML = statusIndicator.outerHTML + ' ' + status;
            }
            
            // Reset the application
            function reset() {
                // Clear markers
                if (pickupMarker) {
                    map.removeLayer(pickupMarker);
                    pickupMarker = null;
                }
                
                if (dropoffMarker) {
                    map.removeLayer(dropoffMarker);
                    dropoffMarker = null;
                }
                
                if (droneMarker) {
                    map.removeLayer(droneMarker);
                    droneMarker = null;
                }
                
                if (routeLine) {
                    map.removeLayer(routeLine);
                    routeLine = null;
                }
                
                // Clear animation
                if (droneAnimation) {
                    clearInterval(droneAnimation);
                    droneAnimation = null;
                }
                
                // Reset UI
                document.getElementById('pickup-coords').textContent = 'Click on the map to set pickup point';
                document.getElementById('dropoff-coords').textContent = 'Click on the map to set dropoff point';
                document.getElementById('find-route').disabled = true;
                document.getElementById('distance').textContent = '-';
                document.getElementById('time').textContent = '-';
                document.getElementById('node-count').textContent = '-';
                
                // Generate new delivery ID
                deliveryId = generateDeliveryId();
                document.getElementById('delivery-id').value = deliveryId;
                
                // Reset status
                updateStatus('Idle');
                
                // Redraw the graph
                drawGraph();
            }
            
            // Event Listeners
            let clickMode = 'pickup'; // 'pickup' or 'dropoff'
            
            map.on('click', function(e) {
                const latlng = e.latlng;
                
                if (clickMode === 'pickup') {
                    // Remove existing pickup marker if any
                    if (pickupMarker) {
                        map.removeLayer(pickupMarker);
                    }
                    
                    // Add new pickup marker
                    pickupMarker = L.circleMarker([latlng.lat, latlng.lng], {
                        radius: 8,
                        fillColor: '#2ecc71',
                        color: '#fff',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8
                    }).addTo(map);
                    
                    // Update UI
                    document.getElementById('pickup-coords').textContent = 
                        `Lat: ${latlng.lat.toFixed(6)}, Lng: ${latlng.lng.toFixed(6)}`;
                    
                    // Switch to dropoff mode
                    clickMode = 'dropoff';
                    document.getElementById('dropoff-coords').textContent = 'Now click to set dropoff point';
                    
                } else if (clickMode === 'dropoff') {
                    // Remove existing dropoff marker if any
                    if (dropoffMarker) {
                        map.removeLayer(dropoffMarker);
                    }
                    
                    // Add new dropoff marker
                    dropoffMarker = L.circleMarker([latlng.lat, latlng.lng], {
                        radius: 8,
                        fillColor: '#e74c3c',
                        color: '#fff',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8
                    }).addTo(map);
                    
                    // Update UI
                    document.getElementById('dropoff-coords').textContent = 
                        `Lat: ${latlng.lat.toFixed(6)}, Lng: ${latlng.lng.toFixed(6)}`;
                    
                    // Enable find route button
                    document.getElementById('find-route').disabled = false;
                    
                    // Reset click mode (optional: allow changing points)
                    clickMode = 'pickup';
                }
            });
            
            // Find route button click handler
            document.getElementById('find-route').addEventListener('click', function() {
                if (!pickupMarker || !dropoffMarker) {
                    alert('Please set both pickup and dropoff points first.');
                    return;
                }
                
                // Disable button to prevent multiple clicks
                this.disabled = true;
                
                // Find nearest nodes to pickup and dropoff points
                const pickupNode = findNearestNode(
                    pickupMarker.getLatLng().lat,
                    pickupMarker.getLatLng().lng
                );
                
                const dropoffNode = findNearestNode(
                    dropoffMarker.getLatLng().lat,
                    dropoffMarker.getLatLng().lng
                );
                
                // Find path using A* algorithm
                const pathNodeIds = aStar(graph, pickupNode.id, dropoffNode.id);
                
                if (pathNodeIds && pathNodeIds.length > 0) {
                    // Draw the path on the map
                    const pathCoords = drawPath(pathNodeIds);
                    
                    // Animate the drone along the path
                    animateDrone(pathCoords);
                } else {
                    alert('No valid path found between the selected points.');
                    this.disabled = false;
                }
            });
            
            // Reset button click handler
            document.getElementById('reset').addEventListener('click', reset);
            
            // Save delivery button click handler
            document.getElementById('save-delivery').addEventListener('click', saveCurrentDelivery);
            
            // Initialize the application
            function init() {
                // Initialize the graph
                initializeGraph();
                
                // Draw the graph on the map
                drawGraph();
                
                // Set initial state
                document.getElementById('find-route').disabled = true;
                
                // Generate initial delivery ID
                deliveryId = generateDeliveryId();
                document.getElementById('delivery-id').value = deliveryId;
                
                // Set initial status
                updateStatus('Idle');
            }
            
            // Start the application
            init();
        });
    </script>
    <script>
        // Add these functions to handle deliveries
        async function saveCurrentDelivery() {
            if (!window.currentPath || window.currentPath.length < 2) {
                alert('Please create a route first');
                return;
            }

            const pickup = window.currentPath[0];
            const dropoff = window.currentPath[window.currentPath.length - 1];
            const notes = document.getElementById('delivery-notes').value;
            
            try {
                // Save delivery data
                const deliveryData = {
                    pickup: { lat: pickup.lat, lng: pickup.lng },
                    dropoff: { lat: dropoff.lat, lng: dropoff.lng },
                    distance: calculatePathDistance(window.currentPath),
                    waypoints: window.currentPath.length > 2 ? window.currentPath.slice(1, -1) : [],
                    notes: notes,
                    status: 'pending'
                };
                
                // Add delivery to Firestore
                const docRef = await saveDelivery(deliveryData);
                
                // Upload image if selected
                const selectedImage = document.getElementById('delivery-image').files[0];
                if (selectedImage) {
                    await uploadDeliveryImage(selectedImage, docRef);
                }
                
                alert('Delivery saved successfully!');
                
                // Reset form
                document.getElementById('delivery-notes').value = '';
                removeImage();
                
            } catch (error) {
                console.error('Error saving delivery:', error);
                alert('Error saving delivery: ' + error.message);
            }
        }

        async function showDeliveryHistory() {
            try {
                const deliveries = await getUserDeliveries();
                const deliveryList = document.getElementById('delivery-list');
                deliveryList.innerHTML = '';

                if (deliveries.length === 0) {
                    deliveryList.innerHTML = '<p>No deliveries found.</p>';
                } else {
                    deliveries.forEach(delivery => {
                        const div = document.createElement('div');
                        div.style.padding = '15px';
                        div.style.borderBottom = '1px solid #eee';
                        div.style.marginBottom = '10px';
                        
                        let imageHtml = '';
                        if (delivery.imageBase64) {
                            imageHtml = `
                                <div style="margin: 10px 0;">
                                    <img src="${delivery.imageBase64}" 
                                         alt="${delivery.imageName || 'Delivery'}" 
                                         style="max-width: 200px; max-height: 150px; border-radius: 4px;">
                                </div>
                            `;
                        }
                        
                        div.innerHTML = `
                            <div style="margin-bottom: 10px;">
                                <p><strong>Status:</strong> <span class="status-${delivery.status || 'pending'}">${delivery.status || 'pending'}</span></p>
                                <p><strong>Distance:</strong> ${delivery.distance ? delivery.distance.toFixed(2) + ' km' : 'N/A'}</p>
                                <p><strong>Created:</strong> ${delivery.createdAt ? new Date(delivery.createdAt.toDate()).toLocaleString() : 'N/A'}</p>
                                ${delivery.notes ? `<p><strong>Notes:</strong> ${delivery.notes}</p>` : ''}
                                ${imageHtml}
                            </div>
                            <div>
                                <button onclick="loadDelivery('${delivery.id}')" 
                                        style="padding: 5px 10px; margin-right: 5px;">
                                    View on Map
                                </button>
                                ${delivery.imageBase64 ? `
                                    <button onclick="deleteDeliveryImage('${delivery.id}')" 
                                            style="padding: 5px 10px; background-color: #ff6b6b; color: white; border: none; border-radius: 3px; cursor: pointer;">
                                        Remove Image
                                    </button>
                                ` : ''}
                            </div>
                        `;
                        deliveryList.appendChild(div);
                    });
                }
                
                document.getElementById('delivery-history-modal').style.display = 'block';
            } catch (error) {
                console.error('Error loading deliveries:', error);
                alert('Error loading deliveries: ' + error.message);
            }
        }
        
        // Add this function to handle image deletion
        async function deleteDeliveryImage(deliveryId) {
            if (confirm('Are you sure you want to delete this image?')) {
                try {
                    await window.deleteDeliveryImage(deliveryId);
                    // Refresh the delivery list
                    showDeliveryHistory();
                } catch (error) {
                    console.error('Error deleting image:', error);
                    alert('Error deleting image: ' + error.message);
                }
            }
        }
        
        // Image handling
        let selectedImage = null;
        
        document.getElementById('delivery-image').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                // Limit to 700KB to stay well under Firestore's 1MB limit
                if (file.size > 700 * 1024) {
                    alert('Image size should be less than 700KB');
                    this.value = ''; // Clear the file input
                    return;
                }
                
                selectedImage = file;
                document.getElementById('image-name').textContent = file.name;
                
                // Show preview
                const reader = new FileReader();
                reader.onload = function(e) {
                    const preview = document.getElementById('preview');
                    preview.src = e.target.result;
                    document.getElementById('image-preview').style.display = 'block';
                };
                reader.readAsDataURL(file);
            }
        });
        
        function removeImage() {
            selectedImage = null;
            document.getElementById('delivery-image').value = '';
            document.getElementById('image-name').textContent = 'No image selected';
            document.getElementById('image-preview').style.display = 'none';
        }
    </script>
</body>
</html>